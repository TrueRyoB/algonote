自己詠唱を繰り返すだけ
とても単純
もしグラフ内探索であれば、[[特注の型]]や[[集合判定木]]を用いて両方向に各辺情報を保存して、親に戻らないように工夫すれば簡単に実装できる。大体多始点なのでfor loopで呼んじゃう。
[[無名関数]]で実装しよう。

~~~cpp:
vector<vector<edge>> e(N);
int ans = 0LL;

//とにかく雑な実装 木じゃなかったらTLE必至
auto dfs= [&](auto dfs, int ci, int cw) {
	if(cur == N-1) {
		 chmax(ans, cw);
		 return;
	}
	for(auto& [v, w] : e[ci]) {
		dfs(dfs, v, cw^ci);
	}
};

//呼び忘れがち
for(int i=0; i<N-1; ++i) dfs(dfs, i, 0LL);

~~~

[[累積和]]