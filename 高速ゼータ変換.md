
[[bit操作]]の[[包除原理]]を活用した集合判定方法
self & child -> childになるような状況で、1つのbit値分少ない子要素から情報収集する術
[[集合]]の判定でとても強い。($O(N2^N)$で実装可能)

~~~cpp
//例題：整数NとA0, A1, ..., A2^N-1が与えられます。
//0<=i<=2^Nを満たす整数iについてj(iを満たす整数jについてのAjの総和をそれぞれ求めなさい。
int dp[1 << N];
for(int i = 0; i < (1 << N); i++){
    dp[i] = A[i];
}
for(int j = 0; j < N; j++){
    for(int i = 0; i < (1 << N); i++){
        if(i & (1 << j)){
            dp[i] += dp[i & ~(1 << j)];
        }
    }
}
for(int i = 0; i < (1 << N); i++){
    cout << dp[i] << endl;
}
~~~